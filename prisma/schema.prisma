generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                          String              @id @default(cuid())
  name                        String?
  email                       String              @unique
  emailVerified               DateTime?
  image                       String?
  passwordHash                String
  role                        Role                @default(STUDENT)
  createdAt                   DateTime            @default(now())
  updatedAt                   DateTime            @updatedAt
  approved                    Boolean             @default(false)
  branchId                    String?
  accounts                    Account[]
  assignmentsAsStudent        Assignment[]        @relation("AssignmentStudent")
  assignmentsAsTeacher        Assignment[]        @relation("AssignmentTeacher")
  bookingsAsStudent           Booking[]           @relation("StudentBookings")
  bookingsAsTeacher           Booking[]           @relation("TeacherBookings")
  classEnrollments            ClassStudent[]
  classesTeaching             Class[]
  examsCreated                Exam[]
  notifications               Notification[]
  payments                    PaymentSchedule[]   @relation("StudentPayments")
  sessions                    Session[]
  enrollments                 StudentEnrollment[] @relation("StudentEnrollments")
  studentProfile              StudentProfile?     @relation("StudentProfileUser")
  studentsTeaching            StudentProfile[]    @relation("TeacherOfStudent")
  teacherProfile              TeacherProfile?     @relation("TeacherProfileUser")
  tuitionPayments             TuitionPayment[]    @relation("StudentTuitionPayments")
  branch                      Branch?             @relation(fields: [branchId], references: [id])
  writingSubmissionsAsGrader  WritingSubmission[] @relation("WritingGrader")
  writingSubmissionsAsStudent WritingSubmission[] @relation("WritingStudent")
  writingSubmissionsAsTeacher WritingSubmission[] @relation("WritingTeacher")

  @@map("users")
}

model Branch {
  id              String              @id @default(cuid())
  name            String              @unique
  createdAt       DateTime            @default(now())
  assignments     Assignment[]
  attempts        Attempt[]
  bookings        Booking[]
  classes         Class[]
  financeTxns     FinanceTxn[]
  payments        PaymentSchedule[]
  enrollments     StudentEnrollment[]
  studentProfiles StudentProfile[]
  tuitionPayments TuitionPayment[]
  users           User[]

  @@map("branches")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

model Class {
  id                 String              @id @default(cuid())
  name               String
  teacherId          String
  createdAt          DateTime            @default(now())
  branchId           String?
  assignments        Assignment[]
  classStudents      ClassStudent[]
  branch             Branch?             @relation(fields: [branchId], references: [id], onDelete: Restrict)
  teacher            User                @relation(fields: [teacherId], references: [id], onDelete: Cascade)
  writingSubmissions WritingSubmission[]

  @@map("classes")
}

model ClassStudent {
  id        String   @id @default(cuid())
  classId   String
  studentId String
  createdAt DateTime @default(now())
  class     Class    @relation(fields: [classId], references: [id], onDelete: Cascade)
  student   User     @relation(fields: [studentId], references: [id], onDelete: Cascade)

  @@unique([classId, studentId])
  @@map("class_students")
}

model Attempt {
  id           String           @id @default(cuid())
  status       String           @default("IN_PROGRESS")
  bandOverall  Float?
  createdAt    DateTime         @default(now())
  bookingId    String?          @unique
  startedAt    DateTime?
  submittedAt  DateTime?
  branchId     String?
  assignmentId String?          @unique
  examId       String
  studentId    String
  answers      Json?
  sections     AttemptSection[]
  assignment   Assignment?      @relation(fields: [assignmentId], references: [id])
  booking      Booking?         @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  branch       Branch?          @relation(fields: [branchId], references: [id], onDelete: Restrict)

  @@index([studentId, status])
  @@index([studentId, createdAt])
  @@index([status, createdAt])
  @@map("attempts")
}

model AttemptSection {
  id                String             @id @default(cuid())
  attemptId         String
  type              SectionType
  answers           Json?
  rawScore          Int?
  bandScore         Float?
  gradedById        String?
  rubric            Json?
  feedback          String?
  startedAt         DateTime?
  endedAt           DateTime?
  status            String             @default("IN_PROGRESS")
  maxScore          Int?
  attempt           Attempt            @relation(fields: [attemptId], references: [id], onDelete: Cascade)
  writingSubmission WritingSubmission?

  @@index([attemptId, type])
  @@map("attempt_sections")
}

model WritingSubmission {
  id                String         @id @default(cuid())
  attemptSectionId  String         @unique
  attemptId         String
  studentId         String
  classId           String?
  teacherId         String?
  task1Response     String
  task2Response     String
  wordCountTask1    Int
  wordCountTask2    Int
  startedAt         DateTime
  submittedAt       DateTime
  timeSpentSeconds  Int
  overallBand       Float?
  task1Band         Float?
  task2Band         Float?
  overallComments   String?
  task1Comments     String?
  task2Comments     String?
  feedbackPublished Boolean        @default(false)
  gradedAt          DateTime?
  gradedById        String?
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt
  attemptSection    AttemptSection @relation(fields: [attemptSectionId], references: [id], onDelete: Cascade)
  class             Class?         @relation(fields: [classId], references: [id])
  gradedBy          User?          @relation("WritingGrader", fields: [gradedById], references: [id])
  student           User           @relation("WritingStudent", fields: [studentId], references: [id], onDelete: Cascade)
  teacher           User?          @relation("WritingTeacher", fields: [teacherId], references: [id])

  @@index([studentId, submittedAt])
  @@index([teacherId, submittedAt])
  @@index([classId, feedbackPublished])
  @@index([attemptId])
  @@map("writing_submissions")
}

model Exam {
  id              String           @id @default(cuid())
  title           String
  isActive        Boolean          @default(true)
  createdById     String?
  createdAt       DateTime         @default(now())
  category        ExamCategory     @default(IELTS)
  track           String?
  durationMin     Int?
  sectionPassword String?
  readingType     String?          @default("ACADEMIC")
  writingType     String?          @default("ACADEMIC")
  bookings        Booking[]
  assignments     ExamAssignment[]
  sections        ExamSection[]
  createdBy       User?            @relation(fields: [createdById], references: [id])
  questions       Question[]
  unitExams       UnitExam[]

  @@map("exams")
}

model Booking {
  id          String        @id @default(cuid())
  studentId   String
  teacherId   String?
  examId      String
  sections    SectionType[]
  startAt     DateTime
  status      String        @default("CONFIRMED")
  createdAt   DateTime      @default(now())
  reminded1h  Boolean       @default(false)
  reminded24h Boolean       @default(false)
  branchId    String?
  attempt     Attempt?
  branch      Branch?       @relation(fields: [branchId], references: [id], onDelete: Restrict)
  exam        Exam          @relation(fields: [examId], references: [id], onDelete: Cascade)
  student     User          @relation("StudentBookings", fields: [studentId], references: [id], onDelete: Cascade)
  teacher     User?         @relation("TeacherBookings", fields: [teacherId], references: [id])

  @@index([studentId, startAt])
  @@index([teacherId, startAt])
  @@map("bookings")
}

model Notification {
  id        String    @id @default(cuid())
  userId    String
  channel   String
  title     String
  body      String
  sentAt    DateTime?
  meta      Json?
  createdAt DateTime  @default(now())
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@map("notifications")
}

model ExamSection {
  id              String        @id @default(cuid())
  examId          String
  type            SectionType
  durationMin     Int           @default(15)
  order           Float         @default(0)
  title           String
  instruction     String?
  image           String?
  image2          String?
  parentSectionId String?       @map("parent_section_id")
  exam            Exam          @relation(fields: [examId], references: [id], onDelete: Cascade)
  parentSection   ExamSection?  @relation("Subsections", fields: [parentSectionId], references: [id], onDelete: Cascade)
  subsections     ExamSection[] @relation("Subsections")
  questions       Question[]

  @@map("exam_sections")
}

model Question {
  id          String        @id @default(cuid())
  examId      String?
  prompt      Json
  options     Json?
  answerKey   Json?
  maxScore    Int           @default(1)
  order       Int
  explanation Json?
  sectionId   String
  qtype       QuestionType
  tags        QuestionTag[]
  Exam        Exam?         @relation(fields: [examId], references: [id])
  section     ExamSection   @relation(fields: [sectionId], references: [id], onDelete: Cascade)

  @@map("questions")
}

model BandMap {
  id       String      @id @default(cuid())
  examType String
  section  SectionType
  minRaw   Int
  maxRaw   Int
  band     Float

  @@map("band_maps")
}

model QuestionTag {
  id         String   @id @default(cuid())
  questionId String
  tag        String
  createdAt  DateTime @default(now())
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@index([tag])
  @@index([questionId])
  @@map("question_tags")
}

model Track {
  id        String   @id @default(cuid())
  name      String   @unique
  kind      String   @default("GENERAL_ENGLISH")
  createdAt DateTime @default(now())
  books     Book[]

  @@map("tracks")
}

model Book {
  id        String   @id @default(cuid())
  title     String
  trackId   String?
  createdAt DateTime @default(now())
  track     Track?   @relation(fields: [trackId], references: [id])
  units     Unit[]

  @@map("books")
}

model Unit {
  id        String     @id @default(cuid())
  bookId    String
  title     String
  order     Int
  createdAt DateTime   @default(now())
  unitExams UnitExam[]
  book      Book       @relation(fields: [bookId], references: [id], onDelete: Cascade)

  @@map("units")
}

model UnitExam {
  id          String       @id @default(cuid())
  unitId      String
  examId      String
  createdAt   DateTime     @default(now())
  assignments Assignment[]
  exam        Exam         @relation(fields: [examId], references: [id], onDelete: Cascade)
  unit        Unit         @relation(fields: [unitId], references: [id], onDelete: Cascade)

  @@map("unit_exams")
}

model Assignment {
  id         String    @id @default(cuid())
  unitExamId String
  studentId  String
  teacherId  String?
  classId    String?
  branchId   String?
  startAt    DateTime?
  dueAt      DateTime?
  status     String    @default("ASSIGNED")
  createdAt  DateTime  @default(now())
  branch     Branch?   @relation(fields: [branchId], references: [id], onDelete: Restrict)
  class      Class?    @relation(fields: [classId], references: [id])
  student    User      @relation("AssignmentStudent", fields: [studentId], references: [id], onDelete: Cascade)
  teacher    User?     @relation("AssignmentTeacher", fields: [teacherId], references: [id])
  unitExam   UnitExam  @relation(fields: [unitExamId], references: [id], onDelete: Cascade)
  attempt    Attempt?

  @@index([studentId, startAt])
  @@index([teacherId, startAt])
  @@map("assignments")
}

model ExamAssignment {
  id          String        @id @default(cuid())
  studentId   String
  examId      String
  sections    SectionType[]
  startAt     DateTime?
  dueAt       DateTime?
  createdById String
  branchId    String?
  createdAt   DateTime      @default(now())
  exam        Exam          @relation(fields: [examId], references: [id], onDelete: Cascade)

  @@index([studentId, examId])
  @@map("exam_assignments")
}

model StudentEnrollment {
  id               String            @id @default(cuid())
  studentId        String
  courseName       String
  courseType       String
  level            String?
  branchId         String?
  enrolledAt       DateTime          @default(now())
  status           String            @default("ACTIVE")
  notes            String?
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  paymentSchedules PaymentSchedule[]
  branch           Branch?           @relation(fields: [branchId], references: [id], onDelete: Restrict)
  student          User              @relation("StudentEnrollments", fields: [studentId], references: [id], onDelete: Cascade)

  @@index([studentId, status])
  @@index([branchId, status])
  @@map("student_enrollments")
}

model PaymentSchedule {
  id            String            @id @default(cuid())
  enrollmentId  String
  studentId     String
  amount        Decimal           @db.Decimal(10, 2)
  dueDate       DateTime
  paidDate      DateTime?
  status        String            @default("PENDING")
  paymentMethod String?
  notes         String?
  branchId      String?
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt
  branch        Branch?           @relation(fields: [branchId], references: [id], onDelete: Restrict)
  enrollment    StudentEnrollment @relation(fields: [enrollmentId], references: [id], onDelete: Cascade)
  student       User              @relation("StudentPayments", fields: [studentId], references: [id], onDelete: Cascade)

  @@index([studentId, dueDate])
  @@index([branchId, dueDate])
  @@index([status, dueDate])
  @@map("payment_schedules")
}

model FinanceTxn {
  id         String   @id @default(cuid())
  branchId   String?
  kind       String
  category   String
  amount     Decimal  @db.Decimal(10, 2)
  currency   String   @default("AZN")
  occurredAt DateTime
  meta       Json?
  createdAt  DateTime @default(now())
  branch     Branch?  @relation(fields: [branchId], references: [id], onDelete: Restrict)

  @@index([branchId, occurredAt])
  @@index([kind, occurredAt])
  @@index([category, occurredAt])
  @@map("finance_txns")
}

model StudentProfile {
  id            String    @id @default(cuid())
  studentId     String    @unique
  branchId      String
  teacherId     String?
  firstEnrollAt DateTime?
  monthlyFee    Decimal?  @db.Decimal(10, 2)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  dateOfBirth   DateTime?
  paymentAmount Decimal?  @db.Decimal(10, 2)
  paymentDate   DateTime?
  phoneNumber   String?
  program       String?
  branch        Branch    @relation(fields: [branchId], references: [id])
  student       User      @relation("StudentProfileUser", fields: [studentId], references: [id], onDelete: Cascade)
  teacher       User?     @relation("TeacherOfStudent", fields: [teacherId], references: [id])

  @@index([branchId])
  @@index([teacherId])
  @@map("student_profiles")
}

model TeacherProfile {
  id          String    @id @default(cuid())
  teacherId   String    @unique
  phoneNumber String
  dateOfBirth DateTime?
  program     String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  teacher     User      @relation("TeacherProfileUser", fields: [teacherId], references: [id], onDelete: Cascade)

  @@index([teacherId])
  @@map("teacher_profiles")
}

model TuitionPayment {
  id        String        @id @default(cuid())
  studentId String
  branchId  String
  year      Int
  month     Int
  amount    Decimal       @db.Decimal(10, 2)
  status    PaymentStatus @default(UNPAID)
  paidAt    DateTime?
  note      String?
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
  branch    Branch        @relation(fields: [branchId], references: [id])
  student   User          @relation("StudentTuitionPayments", fields: [studentId], references: [id], onDelete: Cascade)

  @@unique([studentId, year, month])
  @@index([branchId, year, month])
  @@index([status, year, month])
  @@map("tuition_payments")
}

enum Role {
  STUDENT
  TEACHER
  ADMIN
  BOSS
  BRANCH_ADMIN
  BRANCH_BOSS
  CREATOR
  PARENT
}

enum ExamCategory {
  IELTS
  TOEFL
  SAT
  KIDS
  GENERAL_ENGLISH
  MATH
}

enum SectionType {
  READING
  LISTENING
  WRITING
  SPEAKING
  GRAMMAR
  VOCABULARY
}

enum QuestionType {
  MCQ
  ORDER
  DND_MATCH
  TF
  MCQ_SINGLE
  MCQ_MULTI
  SELECT
  INLINE_SELECT
  GAP
  ORDER_SENTENCE
  DND_GAP
  SHORT_TEXT
  ESSAY
  TF_NG
  FILL_IN_BLANK
  SPEAKING_RECORDING
}

enum PaymentStatus {
  PAID
  UNPAID
}
